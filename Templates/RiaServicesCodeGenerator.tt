
<#
	//
	// TITLE: T4 template to generate RIA Services files based on an EDMX file
	//
	// DESCRIPTION:
	// This template uses external generators supplied by a calling template to generate files.
    // This template cannot be called directly
#>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data" #>
<#@ assembly name="System.Data.Entity" #>
<#@ assembly name="System.Data.Entity.Design" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>

<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Data.Entity.Design" #>
<#@ import namespace="System.Data.Metadata.Edm" #>
<#@ import namespace="System.Data.Mapping" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Data.Objects" #>
<#@ Import Namespace="Microsoft.VisualStudio.TextTemplating" #>

	<#+
    public enum OutputTypes {BusinessObject, Metadata, SharedInterfaces};
    
    public void StartGeneration(RiaServicesCodeGenerator codeGenerator)
    {
        codeGenerator.EdmxFilePath = Path.Combine(Path.GetDirectoryName(this.Host.TemplateFile), codeGenerator.EdmxFilePath);
        codeGenerator.AssemblyPath = Path.Combine(Path.GetDirectoryName(this.Host.TemplateFile), codeGenerator.AssemblyPath);
        this.Write(codeGenerator.TransformText());

    }

    private void LoadAssembly(string assemblyPath)
    {
        String tempFilePath = Path.GetTempFileName();
        File.Copy(assemblyPath, tempFilePath, true);
        Assembly.LoadFrom(tempFilePath);
    }

    private static List<PropertyInfo> GetEntityProperties(Assembly sourceAssembly, String entityName)
    {
        Type entityType;
        entityType = FindType(sourceAssembly, entityName);
        return (from p in entityType.GetProperties() where p.Name != "EntityKey" && p.Name != "EntityState" select p).ToList();
    }
    private static Type FindType(Assembly sourceAssembly, string typeFullName)
    {
        return (from t in sourceAssembly.GetExportedTypes()
                where t.FullName == typeFullName
                select t).First();
    }
        
    public class RiaServicesCodeGenerator: TextTransformation
    {
        public string TargetNamespaceName = null;
        public string SourceNamespaceName = null;
        public string ClassName = null;
        public string ObjectType = null;
        public string EdmxFilePath = null;
        public string AssemblyPath = null;
        public string EntityContainerName = null;
        public OutputTypes OutputType = OutputTypes.BusinessObject;
        public List<String> WireUpInterfaceEntityList { get; set; }
        public override string TransformText()
        {
            
		    List<EntityType> entities;
            Assembly sourceAssembly;
		    if (File.Exists(EdmxFilePath) && File.Exists(AssemblyPath))
		    {
			    entities = GetEntities(EdmxFilePath);
                sourceAssembly = GetAssembly(AssemblyPath);
                if (OutputType == OutputTypes.BusinessObject)
                {
                    RiaServicesBOTemplate boTemplate = new RiaServicesBOTemplate();
                    boTemplate.SourceNamespaceName = SourceNamespaceName;
                    boTemplate.TargetNamespaceName = TargetNamespaceName;
                    boTemplate.ClassName = ClassName;
                    boTemplate.Entities = entities;
                    boTemplate.EntityContainerName = EntityContainerName;
                    this.Write(boTemplate.TransformText());
                }
                else if (OutputType == OutputTypes.Metadata)
                {
                    bool writeHeader = true;
                    foreach (EntityType currentEntity in entities)
                    {
                        RiaServicesMetadataTemplate mdTemplate = new RiaServicesMetadataTemplate();
                        mdTemplate.Entity = currentEntity;
                        mdTemplate.SourceAssembly = sourceAssembly;
                        mdTemplate.WriteHeader = writeHeader;
                        writeHeader = false;
                        mdTemplate.TargetNamespaceName = TargetNamespaceName;
                        mdTemplate.SourceNamespaceName = SourceNamespaceName;
                        this.WriteLine(mdTemplate.TransformText());
                    }
                    if (!string.IsNullOrEmpty(this.TargetNamespaceName))
                        this.WriteLine(RiaServicesMetadataTemplate.Footer);
                }
                else if (OutputType == OutputTypes.SharedInterfaces)
                {
                    bool writeHeader = true;
                    foreach (EntityType currentEntity in entities)
                    {
                        
                        RiaServicesSharedInterfaceTemplate siTemplate = new RiaServicesSharedInterfaceTemplate();
                        siTemplate.Entity = currentEntity;
                        siTemplate.SourceAssembly = sourceAssembly;
                        if (WireUpInterfaceEntityList.Contains("*") || WireUpInterfaceEntityList.Contains(currentEntity.Name))
                            siTemplate.WireUp = true;
                        siTemplate.WriteHeader = writeHeader;
                        writeHeader = false;
                        siTemplate.SourceNamespaceName = SourceNamespaceName;
                        siTemplate.TargetNamespaceName = TargetNamespaceName;
                        this.WriteLine(siTemplate.TransformText());
                    }
                    if (!string.IsNullOrEmpty(this.TargetNamespaceName))
                        this.WriteLine(RiaServicesSharedInterfaceTemplate.Footer);
                }
                
            }
		    else
		    {
               this.Error(String.Format("No business objects were generated. Cannot find file {0}. Ensure the project has an EDMX file and the file name of the .tt file is of the form [edmx-file-name].BusinessObjects.tt", EdmxFilePath));
                this.Write(String.Format("No business objects were generated. Cannot find file {0}. Ensure the project has an EDMX file and the file name of the .tt file is of the form [edmx-file-name].BusinessObjects.tt", EdmxFilePath));
		    }
    		return this.GenerationEnvironment.ToString();
	    }
       
	    private List<EntityType> GetEntities(string edmxFilePath)
	    {
		    List<EntityType> returnCollection = new List<EntityType>();
		    try
		    {
			    using (StreamWriter writer = new StreamWriter(new MemoryStream()))
			    {
				    XmlReader csdlReader = null;
				    XmlReader mslReader = null;
				    XmlReader ssdlReader = null;

				    // Crack open the EDMX file and get readers over the CSDL, MSL and SSDL portions
				    GetConceptualMappingAndStorageReaders(edmxFilePath, out csdlReader, out mslReader, out ssdlReader);

				    // Initialize item collections
				    EdmItemCollection edmItems = new EdmItemCollection(new XmlReader[] { csdlReader });
				    StoreItemCollection storeItems = new StoreItemCollection(new XmlReader[] { ssdlReader });
				    StorageMappingItemCollection mappingItems = new StorageMappingItemCollection(edmItems, storeItems, new XmlReader[] { mslReader });
				    foreach (GlobalItem item in edmItems.GetItems<EntityType>())
                    {
                        returnCollection.Add((EntityType)item);                    
                    }

			    }
		    }
		    catch (Exception ex)
		    {
                
			    // log error
			    this.Error(ex.ToString());
		    }

		    return returnCollection;
	    }
        private Assembly GetAssembly(string assemblyPath)
        {
            String tempFilePath = Path.GetTempFileName();
                File.Copy(assemblyPath, tempFilePath, true);            
                return Assembly.LoadFrom(tempFilePath);   
            
        }
    	
	    private void GetConceptualMappingAndStorageReaders(string edmxFile, out XmlReader csdlReader, out XmlReader mslReader, out XmlReader ssdlReader)
        {
            csdlReader = null;
            mslReader = null;
            ssdlReader = null;

            XNamespace edmxns = "http://schemas.microsoft.com/ado/2007/06/edmx";
            XNamespace csdlns = "http://schemas.microsoft.com/ado/2006/04/edm";
            XNamespace mslns = "urn:schemas-microsoft-com:windows:storage:mapping:CS";
            XNamespace ssdlns = "http://schemas.microsoft.com/ado/2006/04/edm/ssdl";

            XDocument edmxDoc = XDocument.Load(edmxFile);
            if (edmxDoc != null)
            {
                XElement edmxNode = edmxDoc.Element(edmxns + "Edmx");
                if (edmxNode != null)
                {
                    XElement runtimeNode = edmxNode.Element(edmxns + "Runtime");
                    if (runtimeNode != null)
                    {
                        // Create XmlReader over CSDL in EDMX
                        XElement conceptualModelsNode = runtimeNode.Element(edmxns + "ConceptualModels");
                        if (conceptualModelsNode != null)
                        {
                            XElement csdlContent = conceptualModelsNode.Element(csdlns + "Schema");
                            if (csdlContent != null)
                            {
                                csdlReader = csdlContent.CreateReader();
                            }
                        }

                        // Create XmlReader over MSL in EDMX
                        XElement mappingsNode = runtimeNode.Element(edmxns + "Mappings");
                        if (mappingsNode != null)
                        {
                            XElement mslContent = mappingsNode.Element(mslns + "Mapping");
                            if (mslContent != null)
                            {
                                mslReader = mslContent.CreateReader();
                            }
                        }

                        // Create XmlReader over SSDL in EDMX
                        XElement storageModelsNode = runtimeNode.Element(edmxns + "StorageModels");
                        if (storageModelsNode != null)
                        {
                            XElement ssdlContent = storageModelsNode.Element(ssdlns + "Schema");
                            if (ssdlContent != null)
                            {
                                ssdlReader = ssdlContent.CreateReader();
                            }
                        }
                    }
                }
            }
        }
    }
    #>